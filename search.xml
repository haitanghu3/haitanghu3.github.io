<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker配置redis时的收获</title>
      <link href="/2022/11/19/docker-pei-zhi-redis-shi-de-shou-huo/"/>
      <url>/2022/11/19/docker-pei-zhi-redis-shi-de-shou-huo/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下均为没有依据的个人理解，仅是帮忙整理个人当前认知用，不出意外大概是漏洞百出，所以如果有其他人看见这篇文章的话当乐子看就行，防止误人子弟</p></blockquote><p>一开始的操作是拉取了一个别人配置好的较为纯净（阉割）版的ubuntu，然后在里面配置上gcc，vim等操作指令，最后再向这个ubuntu的linux系统里从头安装上一个redis。折腾了好久最后redis能打开了，但是没有配置好redis在容器打开时的自动启动，所以最后选择了先放弃这个办法。据说使用 dockerfile可以配置这个系统开启时自动执行的代码。有关这一点后面会解释到。</p><p>首先先从我当前建立的理解来阐述一下我所认为的docker运行机制。首先我们在我们的window系统上通过wsl（windows系统下的linux虚拟机）运行docker。我们的dockerDesktop软件只是一个放在我们windows系统里用来简化操作linux虚拟机的一个辅助者，实际上的docker内核是跑在Linux系统里的。然后别人配置好一个运行在linux系统下的一套程序后，可以把这套程序连带环境一起封装在一个容器中，用容器形成镜像（类似于一个快照，可以用来还原并生成容器【好像游戏里的建造图纸？】）并把它在docker社区里公布给大家。</p><p>我们可以从网络上获取别人发布的镜像，可以直接拉下来用，也可以建立一个叫DockerFile的文件，在原本的镜像基础上RUN几条新的指令，这个已经被run过指令的文件可以产生一个新的镜像。镜像都保存在linux系统里。</p><p>当我们需要直接开盖即食别人配置好的环境与其中的程序时，我们可以用镜像生成相应的容器，运行并进入这个容器我们就能实现在本地的linux系统上连带着环境跑别人的程序（大概就是节约了配环境的力气）。</p><p>具体代码操作：</p><p>先是从docker层面，当我们windows系统里安装了DockerDesktop之后，我们在cmd命令行里就可以使用docker相关的命令了。</p><p>首先是拉取别人配好的镜像作为基础（暂时还没有尝试过从头形成自己的镜像 ），使用的代码为 </p><pre class="line-numbers language-shell"><code class="language-shell">docker pull {镜像名称}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然也可以在某个镜像的基础上编写一个dockerfile，然后使用代码</p><pre class="line-numbers language-shell"><code class="language-shell">docker build 后面怎么写忘了<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来形成一个更加个性化的镜像</p><p>之后就能在我们的桌面app上的IMAGE(镜像)栏里看到多了一个拉取下来的镜像。如下图</p><p><img src="/2022/11/19/docker-pei-zhi-redis-shi-de-shou-huo/image-20221120111637834.png" alt="image-20221120111637834"></p><p>之后我们可以选择点击右边的RUN来利用镜像形成一个容器（会跳出弹窗用来设置容器名称等）</p><p>也可以在cmd里使用代码</p><pre class="line-numbers language-shell"><code class="language-shell">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>来查看当前所有镜像，然后使用</p><pre class="line-numbers language-shell"><code class="language-shell">docker run -it {镜像名称}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时候就能用当前镜像形成一个新的容器并进入。</p><p>所有的容器都可以在桌面app的Containers栏中见到，也可以点击运行</p><p>在cmd中使用<code>docker ps</code>可以查看当前正在运行的所有容器</p><p>然后使用代码</p><pre class="line-numbers language-shell"><code class="language-shell">docker exec -it {容器id} bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就可以进入容器内部。</p><p>在容器内部，使用代码</p><pre class="line-numbers language-shell"><code class="language-shell">service-cli -a {密码}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>就能进入redis自带的控制台</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习</title>
      <link href="/2022/10/19/redis-xue-xi/"/>
      <url>/2022/10/19/redis-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="Redis学习"><a href="#Redis学习" class="headerlink" title="Redis学习"></a>Redis学习</h3><p>引入：NoSQL数据库</p><p>我们为了处理在访问量较大时的服务器CPU和内存压力，有时会用到服务器集群（这个可以去看隔壁 springCloud?），但是在处理访问session时，分开的服务器会导致session信息不能共通。在原来的解决方式中，使用cookies不安全，使用session复制浪费资源，所以提出了使用NoSQL数据库来统一存储登录信息。另外，使用缓存数据库也可以减少数据库访问的io压力。</p><p>redis就是一种典型的NoSQL数据库</p><p>（看到这里发现要先学Linux，淦）</p><p>（然后发现又要先学Docker，路漫漫其修远兮啊）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springCloud学习</title>
      <link href="/2022/09/26/springcloud-xue-xi/"/>
      <url>/2022/09/26/springcloud-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>微服务的服务集群里的微服务互相调用时，可以用注册中心统一管理每个服务的ip、端口、功能等，在上面拉取就好</p><p>同理还有一个配置中心，统一管理配置的变更，实现配置的热更新</p><p>为了管理用户可以访问的微服务，还需要服务网关来校验用户身份、负载均衡，路由具体服务</p><p>数据库的集群还可以有分布式缓存，提高效率，使用高并发</p><p>面对复杂的大量数据统计和分析，还有分布式搜索</p><p>还需要用消息队列来实现异步通信，提高服务的并发性</p><p>为了解决服务的异常定位，还可以使用分布式日志服务，统计所有服务的日志并分析</p><p>还有系统监控和链路追踪，对服务状态，cpu负载，内存占用等进行管理，对问题进行定位</p><p>对于大量的服务部署，我们可以使用Jenkinsdui进行统一编译，基于docker形成镜像，再基于kubernetes和RANCHER这样的技术实现自动化部署，这套技术叫做持续集成。</p><p>完整技术栈图片长这样</p><p><img src="/2022/09/26/springcloud-xue-xi/image-20220926181052743.png" alt="image-20220926181052743"></p><p>涉及到的技术如下</p><p> <img src="/2022/09/26/springcloud-xue-xi/image-20220926181319488.png" alt="image-20220926181319488"></p><p>认识微服务</p><p>不同微服务架构使用的技术内容</p><p><img src="/2022/09/26/springcloud-xue-xi/image-20220926185757038.png" alt="image-20220926185757038"></p><p>SpringCloud的大致技术组成</p><p><img src="/2022/09/26/springcloud-xue-xi/image-20220926190506799.png" alt="image-20220926190506799"></p><p>简单的远程调用（基于http）</p><p>先在想要发出请求的那个项目的Application里注册以下bean</p><p>（当然，写在任何配置类里也行，此处只是因为启动类默认也是配置类）</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> RestTemplate <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后到想要远程调用的service里，模仿如下代码(记得提前封装好要用来接收的实体类)</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> OrderMapper orderMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RestTemplate restTemplate<span class="token punctuation">;</span>    <span class="token keyword">public</span> Order <span class="token function">queryOrderById</span><span class="token punctuation">(</span>Long orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1.查询订单</span>        Order order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2.利用RestTemplate发起http请求,查询相关用户</span>        <span class="token comment" spellcheck="true">// 2.1.url路径</span>        String url <span class="token operator">=</span> <span class="token string">"http://localhost:8081/user/"</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> User<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.完成封装</span>        order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 4.返回</span>        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Eureka入门</p><p>针对一个业务，存在一个提供者和一个消费者，即接口提供者和接口调用者</p><p>原理分析</p><p>由于在业务实现中，服务调用的消费者可能会调用不同提供者的接口，所以需要一个注册中心eureka-server来动态存储这些接口的位置，方便消费者调用</p><p>过程：</p><p>1.服务提供者向注册中心注册服务信息</p><p>2.注册中心记录名称和端口乃至消费者的名称端口</p><p>3.消费者向注册中心拉取所需的服务信息</p><p>4.消费者利用==负载均衡==挑选出所需的端口</p><p>5.消费者远程调用所需服务</p><p><em>5.1服务会每30秒向注册中心发送一次心跳信息以表明自己运行正常,一旦不跳了就会把它从列表中剔除，消费者也就拉取不到了</em></p><p>==什么是负载均衡==这点在14p好像会说</p><p><img src="/2022/09/26/springcloud-xue-xi/image-20220927212609560.png" alt="image-20220927212609560"></p><p>eureka注册中心的搭建方法</p><p>大致事先配置如下图</p><p><img src="/2022/09/26/springcloud-xue-xi/image-20220927213139434.png" alt="image-20220927213139434"></p><p>先右键自己的项目最大文件夹，右键New-&gt;Module-&gt;Maven-&gt;起名为eureka-server</p><p>后finish</p><p>然后在新建的eureka-server的pom文件中加入以下依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>如果出现了报错那就多加个version指定或者重新创建一次这个子项目</em></p><p>然后创建如下启动类（记得预先封装好几层文件夹）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@EnableEurekaServer</span><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EurekaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>EurekaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处<code>@EnableEurekaServer</code>如果出现爆红可能是springcloud依赖引入版本太低的问题，具体可以看<a href="https://blog.csdn.net/linhaibing009/article/details/99086738" target="_blank" rel="noopener">这个网址</a>。</p><p>然后新建yml文件，加入以下配置</p><pre class="line-numbers language-yml"><code class="language-yml">server:  port: 10086spring:  application:    name: eureka-servereureka:  client:    service-url:      defaultZone: http://127.0.0.1:10086/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处之所以eureka还配置了自己的地址信息，是用于未来要用到eureka集群的情况</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网概论阅读笔记</title>
      <link href="/2022/09/05/ji-wang-gai-lun-yue-du-bi-ji/"/>
      <url>/2022/09/05/ji-wang-gai-lun-yue-du-bi-ji/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高并发学习</title>
      <link href="/2022/08/25/gao-bing-fa-xue-xi/"/>
      <url>/2022/08/25/gao-bing-fa-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="高并发学习笔记"><a href="#高并发学习笔记" class="headerlink" title="高并发学习笔记"></a>高并发学习笔记</h2><blockquote><p>出自b站马士兵的相关教程</p></blockquote><h4 id="1-程序运行的底层原理"><a href="#1-程序运行的底层原理" class="headerlink" title="1.程序运行的底层原理"></a>1.程序运行的底层原理</h4><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825082926353.png" alt="计算机的组成"></p><p><strong>程序是什么？</strong> –&gt; XX.exe （躺在磁盘里）</p><p><strong>进程是什么？</strong> –&gt; “程序启动，进入内存”  资源分配的基本单位（似乎为数据+指令）</p><p><strong>线程是什么？</strong> –&gt; 程序执行的基本单位</p><p><strong>程序如何开始运行？</strong> –&gt; CPU读指令：PC存储指令地址、Register读数据、ALU进行数学计算，回写，下一条</p><p><strong>程序如何调度？</strong></p><p>–&gt; 原始时所有app可以直接操作硬件，为了管控这些app，出现了操作系统。没当某个app产生某个线程，操作系统就会进行线程调度，决定哪个线程放入哪个cpu执行。</p><p>但是上方这个调动不是a做完再换b，而是a做一会儿再换b再换回a这样。为了保存上一次操作某个线程的现场，就需要把上次操作的情况存入cache（缓存）。这些叫做<strong>线程的切换</strong>。</p><h4 id="2-CAS（compare-and-swap）的实现"><a href="#2-CAS（compare-and-swap）的实现" class="headerlink" title="2.CAS（compare and swap）的实现"></a>2.CAS（compare and swap）的实现</h4><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825213702227.png" alt="image-20220825213702227"></p><p>表层逻辑如上图</p><p>和sympathizer和volatile一样，底层实现逻辑都是靠lock指令在硬件级别锁定一个北桥芯片。</p><h5 id="内存布局："><a href="#内存布局：" class="headerlink" title="内存布局："></a>内存布局：</h5><p>可以使用openJDK里的工具JOL来直接输出某个对象的内存布局。其maven调用如下：</p><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825150308264.png" alt="JOL"></p><p>比如要查询一个新创建的Object的布局，查看代码如下：</p><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825150451786.png" alt="image-20220825150451786"></p><p>（下面那一行被注释的代码可以输出后发现markword改变，即得锁的信息储存在对象头里，如下图）</p><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825192144597.png" alt="image-20220825192144597"></p><p>此处可以先了解对象在内存中是这样存储的，如图：</p><p><em>markword大小为8个字节64位，</em></p><p><em>类型指针本来是8字节，但由于默认的压缩机制，存储时为4字节，</em></p><p><em>最后会通过加空白让对象的大小为8字节的整数倍。</em></p><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825151442362.png" alt="image-20220825151442362"></p><h4 id="3-锁升级的过程"><a href="#3-锁升级的过程" class="headerlink" title="3.锁升级的过程"></a>3.锁升级的过程</h4><p>锁和GC标记信息都会被存储在对象头markword里，其中锁的种类有下图几种</p><p><img src="/2022/08/25/gao-bing-fa-xue-xi/image-20220825202526014.png" alt="image-20220825202526014"></p><p><em>【ps：上图中有一个hashcode，这东西是用来给对象分类的，方便在使用的过程中查找。同类的对象会有相同的hashcode，在再某堆hashcode相同的对象里通过equals()找到指定的对象。从而提高查找效率】</em></p><p>一个对象刚刚new出来的时候为<strong>无锁态</strong>。<strong>（无锁态和下面的无锁不是一种东西）</strong></p><p>当第一个线程使用某个对象时，使用的锁为<strong>偏向锁</strong>，即标记上该线程自己的标志（指向当前线程的指。针），其他线程发现这个对象时就不会使用。这样就不需要去向操作系统申请重量级锁，从而提升了效率。（这种锁适用于没有发生竞争的时候，即实质上从头到尾只有第一个线程使用了该对象）</p><p>当发生了其他线程与第一个线程的竞争时，偏向锁会升级为<strong>轻量级锁</strong>（又叫<strong>自旋锁</strong>、<strong>无锁</strong>）其过程为：撤销之前的偏向锁，原线程和新线程都在自己的线程栈里生成自己的一个对象lock record（LR），两个LR发生争抢，这个争抢是<strong>自旋过程</strong>：某个线程先读出对象的锁的位置里原来的值，改成一个指向自己LR的指针，再尝试往回写。在回写之前检查那个位置的值是否和之前读的一样，如一样则争抢成功。失败方会反复重复自旋读写的过程，当然在成功者结束前会它还会一直失败。</p><p>当某个自旋的锁自旋超过10次或者在自旋等待的锁超过了cpu核数的1/2，则轻量级锁会被升级为<strong>重量级锁</strong>（这个规则在jdk1.6之后加入了自适应自旋，由jvm自己判断）。</p><p><em>操作系统一般分为用户态和内核态(两者之间互相切换)，内核态用来执行大部分那些直接操作硬件的任务，用户态来运行应用程序。当要操作硬件时，由内核代为执行。而锁在内核中是一群有数量限制的互斥的数据结构。只有应用程序等想内核申请使用重量级锁，内核才能给予它们锁，即一个指向重量级锁的指针。</em></p><p>重量级锁内含队列，它可以让之前在自旋的线程们在队列中停止等待（wait或阻塞），从而不再持续消耗cpu。当轮到某个线程时由操作系统指定打开。</p><p>锁降级会在一些特定的情况下发生（GC的时候）（Garbage Collection），没什么意义。</p><p>关于锁还有两个概念分别叫做<strong>逃逸分析</strong>和<strong>同步省略</strong>，同步省略又被叫做<strong>锁消除</strong>，相关的具体解释可以查看此处：<a href="https://zhuanlan.zhihu.com/p/86710090" target="_blank" rel="noopener">深入理解Java中的逃逸分析</a>。<strong>锁粗化</strong>的原理作用也差不多，此处不多赘述。</p><p>（上面这个链接里还顺便解释了JIT即时编译技术，也就是把热点代码直接翻译成机器语言缓存起来）</p><p>2022/8/25 21:49</p><hr><h4 id="4-缓存行（cache-line）的概念"><a href="#4-缓存行（cache-line）的概念" class="headerlink" title="4.缓存行（cache line）的概念"></a>4.缓存行（cache line）的概念</h4><p>计算机在读取数据的时候从main mamory -&gt; L3 Cache -&gt; L2 Cache -&gt; L1 Cache 的过程是按块读的，即除了当前需要的数据本身还有其后面的一片，这样就可以避免之后要用到后面数据时反复上方的过程。而这一个块就被成为一个cache line，大小为64字节。</p><p>在cpu层级中，为了维持<strong>数据的一致性</strong>，如果有两个线程同时对同一个cache line里的数据进行了修改，当一个线程发生了修改后，它要通知其他线程这个修改。<em>因此，如果我们使用继承等手段把一个对象的大小刚好凑在（放大到）64字节，使之不可能与其他对象在同一缓存行，修改之时不会互相影响，运行速度反而会变快。</em>这种写法叫做<strong>缓存行对齐</strong>。有一个框架叫做disruptor（闪电）底层用了这个原理。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> 后端 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCodeEveryDay</title>
      <link href="/2022/08/06/leetcodeeveryday/"/>
      <url>/2022/08/06/leetcodeeveryday/</url>
      
        <content type="html"><![CDATA[<h3 id="LeetCode每日任务（持续更新）"><a href="#LeetCode每日任务（持续更新）" class="headerlink" title="LeetCode每日任务（持续更新）"></a>LeetCode每日任务（持续更新）</h3><blockquote><p>这是一个用来完成leetcode每日打卡的打卡点，用来记录难度不高的题目。如果有难度价值比较高的题目再单独开新贴整理。</p></blockquote><hr><h5 id="1408-数组中的字符串匹配"><a href="#1408-数组中的字符串匹配" class="headerlink" title="1408. 数组中的字符串匹配"></a>1408. 数组中的字符串匹配</h5><p><img src="/2022/08/06/leetcodeeveryday/image-20220806173534754.png" alt="image-20220806173534754"></p><p>看到这题时感觉和之前的赎金信有异曲同工之妙，自己的解法是手搓包含判断函数，直接利用charAt对两个word进行复杂度为n(m-n)的遍历判断（之所以出现减号式子是因为长度超出后肯定无法匹配而且会出现越界问题）。之后再对words进行n(n-1)的判断遍历每一种组合，得到为true而且不重复的存入list中。</p><p>但是官方题解让我大开眼界。原来直接用<code>if(word[i].contains(word[j]))</code>就能满足题意中的包含性判断，我自己写的那个包含判断函数可以说是浪费力气了。其余官方题解与自己差不多，就不多赘述。</p><p>补充：看了看其他人的解法，还有一种操作是<code>ss[j].indexOf(ss[i]) &gt;= 0</code>这个方法是返回子字符串在父字符串中第一次出现的位置，也算是开了眼界了。</p><h5 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a>2. 两数相加</h5><p><img src="/2022/08/06/leetcodeeveryday/image-20220806194454911.png" alt="image-20220806194454911"></p><p>居然又遇到中等难度的题了。但逻辑并不困难，就是两个链表的逐项相加并且实现足10进1。自己的解法是用两个指针分别指向两个链表头，之后每次都向后移动一节，当某个指针的后一项不是null的时候，就后移并记录移动后的val，否则给val赋值为0，然后结果链表新增一节val为两个val相加。</p><p>完成以上步骤后，加法操作就结束了。但还没满足足10进1的要求。我们再新增一个指针指在结果链表的头上，每次后移时判断是否大于9，如大于9则减10并在后移后把值+1。在末尾出再额外判断是否要新增一节val为的。</p><p>官方的解法是把加法和足10进1的规则集成到了一起。总的来说没有特别的奇思妙想，但既然是个中级题也记录一下标准解法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode head <span class="token operator">=</span> null<span class="token punctuation">,</span> tail <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n1 <span class="token operator">=</span> l1 <span class="token operator">!=</span> null <span class="token operator">?</span> l1<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> n2 <span class="token operator">=</span> l2 <span class="token operator">!=</span> null <span class="token operator">?</span> l2<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sum <span class="token operator">=</span> n1 <span class="token operator">+</span> n2 <span class="token operator">+</span> carry<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                head <span class="token operator">=</span> tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                tail <span class="token operator">=</span> tail<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            carry <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>carry <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            tail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>carry<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过把进位规则量化而减少判断倒是可以学一学。</p><p>22-08-06 19:54</p><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCodeDay1</title>
      <link href="/2022/08/05/leetcodeday1/"/>
      <url>/2022/08/05/leetcodeday1/</url>
      
        <content type="html"><![CDATA[<h3 id="初见LeetCode，题目整理"><a href="#初见LeetCode，题目整理" class="headerlink" title="初见LeetCode，题目整理"></a>初见LeetCode，题目整理</h3><blockquote><p>由于之前鸽了，本次整理包括的内容题目较多，虽然普遍不算难</p><blockquote><p>内含：1480、383、412、876、1342、1672、1403、623、1</p></blockquote></blockquote><h5 id="1480-一维数组的动态和"><a href="#1480-一维数组的动态和" class="headerlink" title="1480. 一维数组的动态和"></a>1480. 一维数组的动态和</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805094300234.png" alt="1480"></p><p>当时我的第一想法是再新建一个大小相同的数组，然后数组的每一项等于其上一项加上原数组的该项，后来发现标准答案里演示的，可以直接操作原数组，原项等于该项加前一项（首项除外），倒是相当精妙。题目过简单，不多赘述。<strong>操作原数组</strong>的思想可以参考。</p><h5 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a>383. 赎金信</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805094850458.png" alt="383"></p><p>自己的解法是先设一个函数，输入字符串与字母，返回字母在字符串中出现的次数<em>（此处用到了个新函数叫<code>str.char(i)</code>，算是个新知识)</em>,然后遍历原字符串1，判断每个字母在字符串1中出现的次数是否会大于字符串2。但是这样的方法复杂度为n+m，题解里的操作类似，但是新建了个数组存储每种字母的出现次数。遍历字符串1，加上出现次数，遍历字符串2，减去出现次数，出现正数时结束。这样的复杂度是n+m，也是比较巧妙的方法。官方解法代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>String ransomNote<span class="token punctuation">,</span> String magazine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> magazine<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ransomNote<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cnt<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要还是学习这种能降低复杂度的思想吧，题目过简单，不多赘述。</p><h5 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a>412. Fizz Buzz</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805154552133.png" alt="412"></p><p>这题就是简单的if判断处理一下。只是新增了个知识就是if判断对运行时间的影响不大，放心用就好。</p><h5 id="876-链表的中间节点"><a href="#876-链表的中间节点" class="headerlink" title="876. 链表的中间节点"></a>876. 链表的中间节点</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805154929177.png" alt="876"></p><p>简单的题目，就是得回顾一下链表类的基本操作。自己的解法是遍历记下总节点数后一路next到一半节点数的位置。官方的解法还有一种叫做<strong>快慢指针</strong>的操作，原理就是设置两个指针，一个一次next一节，一个一次next两节，第一个到结尾时第二个就在中点，还是颇为有趣的。快慢指针代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode slow <span class="token operator">=</span> head<span class="token punctuation">,</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> fast<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            slow <span class="token operator">=</span> slow<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            fast <span class="token operator">=</span> fast<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> slow<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1342-将数字变成-0-的操作次数"><a href="#1342-将数字变成-0-的操作次数" class="headerlink" title="1342. 将数字变成 0 的操作次数"></a>1342. 将数字变成 0 的操作次数</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805155558745.png" alt="1342"></p><p>没什么难度，把处理操作封装一下，然后在主函数统计操作次数就好，但是官方答案好像颇为看不懂，代码如下:</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">numberOfSteps</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ret <span class="token operator">+=</span> <span class="token punctuation">(</span>num <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>num <span class="token operator">&amp;</span> <span class="token number">0x01</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前半是是否除2，后半是是否减1</span>            num <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>num &amp; 0x01</code> 是求num的二进制的最后一位，即<strong>num为奇数时为1，偶数时为0</strong>。</p><p><code>num &gt;&gt;= 1</code>是把num二进制右移一位，即<strong>除2后向下取整</strong>。</p><p>这两个操作可以让代码更优雅且效率更快（？ 以后可以学着用一用。</p><h5 id="1672-最富有客户的资产总量"><a href="#1672-最富有客户的资产总量" class="headerlink" title="1672. 最富有客户的资产总量"></a>1672. 最富有客户的资产总量</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805163807109.png" alt="1672"></p><p>这题也简单，自己的解法是遍历每个用户，再遍历每人的资产求和。官方答案复杂度也一样，就是有个操作是<code>Arrays.stream(account).sum()</code>可以用于求和，虽然不能降低复杂度，但可以让代码优雅一点。</p><h5 id="1403-非递增顺序的最小子序列"><a href="#1403-非递增顺序的最小子序列" class="headerlink" title="1403. 非递增顺序的最小子序列"></a>1403. 非递增顺序的最小子序列</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805170326858.png" alt="1403"></p><p>这题看着很长，但实际上很简单，就是排序后由大到小求和直到大于二分之一的总和。和官方解法的区别就是它用了更简便的<code>int total = Arrays.stream(nums).sum();</code>和<code>Arrays.sort(nums);</code>来实现求和以及排序。以后也可以学着用一用。</p><h5 id="623-在二叉树中增加一行"><a href="#623-在二叉树中增加一行" class="headerlink" title="623. 在二叉树中增加一行"></a>623. 在二叉树中增加一行</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805173754352.png" alt="623"></p><p>终于第一次碰到中等难度的题目了啊…带来的压迫感果然也是简单难度所不能比拟的。最后也是参考了一下题解才通过的。粗略的解法说明就是，对原树执行深度为d的增行操作，等同于对其root的左右分支执行深度为d-1的增行操作，同理<strong>递归</strong>。只要再加上输入root为0的特判、depth为1的特判和depth为1的最终处理（在左右分支前新增一项并接上root）即可。代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() {} *     TreeNode(int val) { this.val = val; } *     TreeNode(int val, TreeNode left, TreeNode right) { *         this.val = val; *         this.left = left; *         this.right = right; *     } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> TreeNode <span class="token function">addOneRow</span><span class="token punctuation">(</span>TreeNode root<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>depth <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            TreeNode t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> root<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> t<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>depth <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>            root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> null<span class="token punctuation">,</span> root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>            <span class="token function">addOneRow</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> val<span class="token punctuation">,</span> depth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addOneRow</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">,</span> depth<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h5><p><img src="/2022/08/05/leetcodeday1/image-20220805230509839.png" alt="1"></p><p>这题不愧是第一题，确实从逻辑上毫无难度。自己的解法就是用for循环遍历一遍所有的组合。但是这样做复杂度比较高。官方给出的解法是使用哈希表，代码如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>感觉从原理上就是用哈希表自带的内部查询取代了一层for循环（？不知道这个<code>containsKey</code>是怎么做到降低复杂度的，但以后也可以试试。</p><p>总而言之，以上9题就是初次接触leetcode的整理与反思。</p><p>其中有7题是新手村的题目，所以普遍难度不高，算是新人福利吧。</p><p>以后尽可能做到当天做题当天整理。</p><p>2022-8-5 23:12</p><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准大二暑假前半部分的项目收获</title>
      <link href="/2022/07/29/summerholidayworkin2022/"/>
      <url>/2022/07/29/summerholidayworkin2022/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个暑假有幸能够作为一个学徒参与了某个与实际公司合作的项目的开发。虽然只负责了其中对于微信二维码支付部分的封装，其中大部分的内容实际上是对官方提供的sdk工具的开盖即食，但由于自己基础知识薄弱，开发经验缺少，导致这么一项简单的任务前前后后也花费了十几天时间。当然其中的收获也颇丰，主要填补了一些在实际项目中的规范操作上的不足，并且涉及到了好多自己以前没有去了解过的知识。暑假过半，趁一时无事，在此整理一下自己的收获。</p></blockquote><h2 id="某只狐狸第一次完成的商业项目实践记录"><a href="#某只狐狸第一次完成的商业项目实践记录" class="headerlink" title="某只狐狸第一次完成的商业项目实践记录"></a>某只狐狸第一次完成的商业项目实践记录</h2><h4 id="第一部分：结构设计"><a href="#第一部分：结构设计" class="headerlink" title="第一部分：结构设计"></a>第一部分：结构设计</h4><p><em>之前由于在六月份一个比赛项目制作文档的时候掌握了一点制作流程图的能力，没想到很快就派上用场了</em>。</p><p>在开始动工项目之前，先理解需求并绘制代码结构组成的流程图带来的帮助比我想象中要大。在实际操作中，有了流程图之后在编写代码时就是“照着图写”，而很少出现一时中断而要花费较长时间重新整理思路的情况。本次项目中最后的设计流程图如下：</p><p><img src="/2022/07/29/summerholidayworkin2022/220729LCT_Part1.png" alt="主体流程图"><br><img src="/2022/07/29/summerholidayworkin2022/220729LTC_Part3.png" alt="轮询流程图"><br>（事实上由于后期前端那边提出了回调的要求，导致以上的图并不代表最终结果，但差别不大)</p><h4 id="第二部分：把API封装入util"><a href="#第二部分：把API封装入util" class="headerlink" title="第二部分：把API封装入util"></a>第二部分：把API封装入util</h4><p><em>本来此处还要利用feign或http的方式自行把接口地址写一套封装，但最后发现微信提供的sdk已经完成了这一项工作，所以这部分算是逃课了，之后有机会再去研究一下sdk里基于http的封装方式吧。</em></p><p>这一步主要流程就是写一套util方法，接收api所需要的参数，调用sdk已经封装好的接口地址访问方法，使用参数进行访问，并把所得的返回结果封装入bean。一下以其中一个较为经典的案例作为代表。</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> WXmicroPayResultBean <span class="token function">wxMicroPay</span><span class="token punctuation">(</span>String body<span class="token punctuation">,</span>                                                  String out_trade_no<span class="token punctuation">,</span>                                                  String total_fee<span class="token punctuation">,</span>                                                  String spbill_create_ip<span class="token punctuation">,</span>                                                  String auth_code<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> params <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"body"</span><span class="token punctuation">,</span>body<span class="token punctuation">)</span><span class="token punctuation">;</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"out_trade_no"</span><span class="token punctuation">,</span>out_trade_no<span class="token punctuation">)</span><span class="token punctuation">;</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"total_fee"</span><span class="token punctuation">,</span>total_fee<span class="token punctuation">)</span><span class="token punctuation">;</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"spbill_create_ip"</span><span class="token punctuation">,</span>spbill_create_ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            params<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"auth_code"</span><span class="token punctuation">,</span>auth_code<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> newParams <span class="token operator">=</span> wxPay<span class="token punctuation">.</span><span class="token function">fillRequestData</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>            Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> res <span class="token operator">=</span> wxPay<span class="token punctuation">.</span><span class="token function">microPay</span><span class="token punctuation">(</span>newParams<span class="token punctuation">)</span><span class="token punctuation">;</span>            WXmicroPayResultBean resultBean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WXmicroPayResultBean</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> resultBean<span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"running error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>值得一提的是，接口地址需要的传入参数和返回参数实际上都要求是XML格式，微信sdk提供方法的里内置了转换的过程，又让我逃了一节课。另外关于返回值的封装新知道了一些小知识：</p><ul><li>即如果是用于程序内部参数传递的封装，一般写在bean层里，而如果是用来向前端返回的封装，一般写在model层里</li><li>一般util允许有返回值，但service层不允许有，而使用把返回值作为参数传入的方法</li></ul><p>除此之外，静态的util如果需要调用非静态且有Exception抛出的方法，当对方法所在的类进行实例化的时候，必须接收下一层抛上来的Exception，并且在catch的过程中也保持为静态。说起来有点抽象，代码实现如下：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> WXPay wxPay<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            wxPay <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WXPay</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WXmicroPayUtil<span class="token punctuation">.</span>WXPayConfigImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以后出现<code>@Autowired</code>又用不了的情况就可以参考是不是上面的原因。</p><h4 id="第三部分：service的建立"><a href="#第三部分：service的建立" class="headerlink" title="第三部分：service的建立"></a>第三部分：service的建立</h4><p><em>在本次项目中，service层的作用就是调用util的方法，把封装好的返回信息bean进行分析和处理，分类成不同的错误原因，通过回调、直接返回等方式返回给前端或者其他需要相关信息的后端业务。直到这次项目，我才明白到一点，即<strong>返回给前端的信息力求简洁明了，错误筛选处理什么的就是后端封装的工作，前端拿个状态码和 message就差不多了。</strong></em></p><p>本次项目service的主要逻辑是，把返回结果分成三类，即订单支付成功、支付失败、支付中，并把相关信息直接返回给前端。而针对支付中的情况，要新开一个线程，反复调用订单查询的util，直到超时或者查到明确的结果，通过回调返回订单支付成功/失败的结果。这样做的好处就是前端无需等待就能第一时间得到返回，而不会让其他业务陷入超时的境地。</p><p>这里涉及到两个新知识点：新开<strong>线程</strong>和<strong>回调</strong>，此处进行分别解释</p><ul><li><strong>线程</strong></li></ul><p><em>我们可以通过一个叫做<code>@Async</code>的注解和其配套注解实现多线程的使用。</em></p><p>当然默认只使用一个<code>@Async</code>好像就能用，springboot好像会默认支持最大线程数为200，但也可以自行配置</p><p>可以自己写一个配置类如下↓，就能凭借注解<code>@Async(&quot;WXTaskExecutor&quot;)</code>使用该配置的线程池了</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableAsync</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WXExecutorConfiguration</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span><span class="token string">"WXTaskExecutor"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Executor <span class="token function">asyncExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadPoolTaskExecutor executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolTaskExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//核心线程数5</span>        executor<span class="token punctuation">.</span><span class="token function">setCorePoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//最大线程数500</span>        executor<span class="token punctuation">.</span><span class="token function">setMaxPoolSize</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//缓冲队列500</span>        executor<span class="token punctuation">.</span><span class="token function">setQueueCapacity</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//允许线程的空闲时间60秒</span>        executor<span class="token punctuation">.</span><span class="token function">setKeepAliveSeconds</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//线程池名的前缀</span>        executor<span class="token punctuation">.</span><span class="token function">setThreadNamePrefix</span><span class="token punctuation">(</span><span class="token string">"WXPayAsync-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        executor<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> executor<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的配置方法有一些使用要点，网络上有相关的整理，截图如下：</p><p><img src="/2022/07/29/summerholidayworkin2022/220729Async.png" alt="失效场景"></p><p>对于其中第三点，在同一个类中，一个非异步方法调用另一个异步方法的问题，可以利用代理类的方法解决。本次项目中就出现了一个非异步的service要调用另一个异步service的情况，解决代码如下：</p><pre class="line-numbers language-java"><code class="language-java">MDealRecordService mDRSProxy <span class="token operator">=</span> <span class="token punctuation">(</span>MDealRecordService<span class="token punctuation">)</span> AopContext<span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>mDRSProxy<span class="token punctuation">.</span><span class="token function">wxLoopTask</span><span class="token punctuation">(</span>out_trade_no<span class="token punctuation">,</span>dealRecord<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当前方法和异步方法都在类<code>MDealRecordService</code>中，而当前方法要在必要时调用异步方法<code>wxLoopTask</code>,所以可以先用以上的代码产生一个代理类实体，然后用该实体调用异步方法。</p><ul><li><strong>回调</strong></li></ul><p><em>我们可以通过回调向指定的url传输指定的信息</em></p><p><em>（这个部分限于不专业的个人理解，只能用于辅助参考，以后可以在新增文章用于回调的深一步了解）</em></p><p>在本次项目中，回调的代码在经过层层封装前，其最核心的部分如下：</p><pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">static</span> RemoteService <span class="token function">CommonRequestUtil</span><span class="token punctuation">(</span>String serverContext<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> Feign<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">options</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Request<span class="token punctuation">.</span>Options</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">3500</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">retryer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Retryer<span class="token punctuation">.</span>Default</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">5000</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">encoder</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JacksonEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">target</span><span class="token punctuation">(</span>RemoteService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>serverContext<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码中的<code>serverContext</code>值为要回调的url，利用返回值实例化一个<code>remoteService</code>,然后利用<code>remoteService</code>调用<code>RemoteService</code>类中的方法<code>multiPlatformDealCallBack</code>,而该方法具体内容又如下：</p><pre class="line-numbers language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//多形态交易回调</span>    <span class="token annotation punctuation">@RequestLine</span><span class="token punctuation">(</span><span class="token string">"GET ?orderId={orderId}&amp;orderType={orderType}&amp;userId={userId}&amp;payType={payType}&amp;payCashes={payCashes}"</span><span class="token punctuation">)</span>    String <span class="token function">multiPlatformDealCallBack</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"orderId"</span><span class="token punctuation">)</span> String orderId<span class="token punctuation">,</span>                                     <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"orderType"</span><span class="token punctuation">)</span> String orderType<span class="token punctuation">,</span>                                     <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span> String userId<span class="token punctuation">,</span>                                     <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"payType"</span><span class="token punctuation">)</span> String payType<span class="token punctuation">,</span>                                     <span class="token annotation punctuation">@Param</span><span class="token punctuation">(</span><span class="token string">"payCashes"</span><span class="token punctuation">)</span> <span class="token keyword">double</span> payCashes<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后就能把以上key和我们塞入的value传给该url</p><p>然而我现在还没看懂其中的原理，有可能与Feign有关，先挖个坑，和第二部分的封装逃课问题以后一起填。</p><p><strong>注（个人理解）：由于异步方法与原来的方法出于不同线程，故异步方法在需求上就不可能即时向调用它的方法返回信息。如果强行返回给某个方法的变量来接收，该异步方法会等待该方法返回而停止运作，这就等同于没有异步甚至浪费资源。就算使用结果作为参数的方法，经过本人测试也只会得到null。故异步方法一般会独自使用回调来向外传输信息。</strong></p><h4 id="第四部分：本地代码的移植与合并"><a href="#第四部分：本地代码的移植与合并" class="headerlink" title="第四部分：本地代码的移植与合并"></a>第四部分：本地代码的移植与合并</h4><p><em>这里总体过程就是在CODING里基于git的分支合并，本身不涉及新的技术，所以把这个模块用于整个项目的查漏补缺。毕竟这些问题也往往是保护分支的管理员在进行合并分支的审核过程中找到的。</em></p><ol><li><strong>关于自动生成的主键</strong></li></ol><p>如果一个类在数据库存储的过程中，其主键id采用的uuid或者是id自增的策略，那么这个类在产生对象时是还不会生成这个id的。即当你new出这个对象时，调用其<code>getId()</code>方法，得到的结果只会是null。</p><p>所以如果我们在后续的代码中需要用到这个对象的id，需要先进行一次save，数据库才能生成其主键。比较优雅的写法就如<code>dealRecord = mDealRecordDao.save(dealRecord);</code>这样这个对象就有id了。</p><ol start="2"><li><strong>关于一些代码规范</strong></li></ol><p>主要要注意的一点就是关于魔法值的封装，甚至是一些像0、1、2这样的状态码也应该给予相应的封装。据说《阿里巴巴Java开发手册（黄山版）》对这些规范有详细的记载，以后可以看看（咕咕）。</p><p><strong>此外在合并的过程中被提出的问题数不胜数，但今天要保持健康作息，就先写到这里吧。有什么需要补充的之后再更新</strong></p><p>​                                                                                                                                        2022-7-29 23:34</p><hr>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>day2_web开发</title>
      <link href="/2022/06/29/springboot2-day2/"/>
      <url>/2022/06/29/springboot2-day2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​    尝试坚持每天学一点中~</p></blockquote><h1 id="Web开发"><a href="#Web开发" class="headerlink" title="Web开发"></a>Web开发</h1><p><strong>1. 静态资源的配置</strong></p><ul><li><p>只要把静态资源文件放在<code>/ststic</code>(or <code>/public</code> or <code>/resource</code>or <code>/META-INF/RESOURCE</code>)的路径下，在web端就可以直接利用url访问到 (在相同的地址情况下先看是不是controller接口，不是则会访问静态资源)</p></li><li><p>为了防止拦截器在拦截/**时把静态资源也拦下，可以在yml中配置</p><pre class="line-numbers language-yml"><code class="language-yml">spring:  mvc:    static-path-pattern: /res/** #(此处res为自定任选)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这样人为配置的静态资源的访问前缀</p></li><li><p>如果要手动指定静态资源的查找位置而舍弃默认路径，可以配置yml</p><pre class="line-numbers language-yml"><code class="language-yml">spring:    web:    resources:      static-locations: [classpath:/haha/] #此处里面写上自定路径比如/haha,方框表示可以有多个形成数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>2. 欢迎页和小图标</strong></p><ul><li>在静态资源文件夹中如果检查到 index.html 文件，这个文件会被作为欢迎页<del>（为什么后端要干前端的活啊）</del>（设置欢迎页和自定义静态资源前缀这两个功能在底层逻辑上相矛盾，只能同时实现一个）</li><li>在静态资源文件夹中如果检查到 favicon.ico 文件，这个文件会被作为小图标(这也和自定义前缀相矛盾)</li></ul><hr><p><em>之后跟着教程读了半天源码，好困，今天早点睡吧，oysm~</em></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot重学day1</title>
      <link href="/2022/06/29/springboot2-day1/"/>
      <url>/2022/06/29/springboot2-day1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>​    由于最近难得有了相对空闲的暑假 <del>小学期</del>时间，决定重新重头学一遍springboot，把自己本来学的半懂不懂的东西彻底搞明白</p></blockquote><h3 id="SpringBoot2-配置文件"><a href="#SpringBoot2-配置文件" class="headerlink" title="SpringBoot2 - 配置文件"></a>SpringBoot2 - 配置文件</h3><p><strong>yml语句的使用规则</strong></p><ul><li><p>使用缩进代表层级关系</p></li><li><p>记得内容前要加空格</p></li><li><p>列表表示法</p><ol><li><p>[阿猫，阿狗]</p></li><li><p>每个成员换行，且之前加上“- ”</p></li><li><p>如果成员也为多数据结构(对象)则使用{english:80,math:90}这样的json写法（还是记得加空格吧）</p></li><li><p>对象也可以首个属性前加“- ”，后续属性换行并列但不加</p></li></ol></li><li><p>要用@ConfigurationProperties(prefix = “XXX”)来把某个类和配置文件里绑定</p></li><li><p>代表字符串时，加不加单/双引号都是一样的结果</p></li><li><p>配置同一个对象时，优先级 properties &gt; yml &gt;yaml</p></li></ul><p><strong>（一个疑似和标题无关的事情）</strong></p><p>貌似在entity中某类的对象上加上<strong>@Data</strong>好像就包含了所有getter、setter、args等构造函数</p><p><strong>使用范例</strong></p><p>假设在entity层里的情况如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ToString</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Pet</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//这是宠物类</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> Double weight<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"person"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Conponent</span>  <span class="token comment" spellcheck="true">//如果去掉这个注解呢?</span><span class="token annotation punctuation">@ToString</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String userName<span class="token punctuation">;</span>    <span class="token keyword">private</span> Date birth<span class="token punctuation">;</span>    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> interests<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//形如 peivate List&lt;String> animals; 与上面interests相同</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> score<span class="token punctuation">;</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>Pet<span class="token operator">>></span> allPets<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么当我们在application.yml中对Person的各属性值进行配置时，格式应该如下</p><pre class="line-numbers language-yaml"><code class="language-yaml"><span class="token key atrule">person</span><span class="token punctuation">:</span>  <span class="token key atrule">username</span><span class="token punctuation">:</span> zhangsan //此处双引号不会额外处理，有换行符就会换行，单引号会返转义（多个杠），使输出时\n保持原状  <span class="token key atrule">interests</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>篮球，足球<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># interests:</span><span class="token comment" spellcheck="true">#   - 篮球</span><span class="token comment" spellcheck="true">#   - 足球</span>  <span class="token key atrule">score</span><span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token key atrule">english</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token key atrule">math</span><span class="token punctuation">:</span> <span class="token number">90</span><span class="token punctuation">}</span>  <span class="token key atrule">allPets</span><span class="token punctuation">:</span>    <span class="token key atrule">sick</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> <span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> 阿狗<span class="token punctuation">,</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">99.99</span><span class="token punctuation">}</span>     <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 阿猫       <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">88.88</span>     <span class="token punctuation">-</span> <span class="token key atrule">name</span><span class="token punctuation">:</span> 阿虫       <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">77.77</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> 阿花<span class="token punctuation">,</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">199.99</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token key atrule">name</span><span class="token punctuation">:</span> 阿明<span class="token punctuation">,</span> <span class="token key atrule">weight</span><span class="token punctuation">:</span> <span class="token number">199.99</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（为了展示多种格式可以混用以上可能看起来并不整齐，实际操作时可以选择一种以统一格式）</p><hr><p><del>睡前再更新一条</del></p><p>为了方便在写yml时可以像自带的配置一样能自动弹出提示，可以在pom.xml中添加以下依赖</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configration-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>optional</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>optional</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><del>(记得写完依赖重启项目)</del></p><p><del>(另外这样的自动配置会把驼峰形写成蛇形)</del></p><p>但是由于以上功能在打包时并不需要使用，为了防止打包时要加载的东西太多，可以在打包相关的配置<code>&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</code>下添加以下配置：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>excludes</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclude</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-configuationprocessor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclude</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>excludes</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样打包的时候这部分就可以被忽略啦~</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
